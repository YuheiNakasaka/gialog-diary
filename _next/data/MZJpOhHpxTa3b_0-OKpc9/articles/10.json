{"pageProps":{"issue":{"body":"[Misreading Chat](https://misreading.chat/2022/05/12/92-software-development-waste/)で紹介されていた[Software Development Waste](https://homepages.dcc.ufmg.br/~figueiredo/disciplinas/papers/icse17sedano.pdf)という論文。\r\n\r\nこの論文に載っていたTypes of Software Development Wasteというソフトウェア開発のムダについて類型されていたものが面白かったので日本語にしてみた。\r\n\r\n# 誤った機能・製品の構築\r\n## ムダ\r\nユーザーニーズやビジネスニーズに対応していない機能・製品を構築するコスト\r\n## 原因\r\n- ユーザーの要望\r\n  - ユーザー調査、検証、テストを行っていない、ユーザーフィードバックを無視している、ユーザー価値の低い機能に取り組んでいる\r\n- ビジネスの要望\r\n  - ビジネス関係者を関与させていない、関係者からのフィードバックが遅い、製品の優先度が不明確\r\n## 一言メモ\r\nユーザーの声を汲み損ねていたり、えいやで作ってしまった機能とかまぁムダですよねと言われてばそう。割とよく起こりがちである。\r\n\r\n# バックログの管理ミス\r\n## ムダ\r\n作業の重複、価値の低いユーザー機能の迅速化、必要なバグ修正の遅延のコスト\r\n## 原因\r\n- バックログの逆転\r\n- 同時に多くの機能に取り組む\r\n- 作業の重複\r\n- 十分に準備されていないストーリー(以降\"ストーリー\"は\"機能\"と同じ意味で使われてるっぽい？)\r\n- 機能開発とバグ修正のアンバランス\r\n- テストまたは重要なバグ修正の遅延\r\n- 気まぐれなスラッシング(訳が微妙)\r\n## 一言メモ\r\n取り組むべきタスクの優先度づけがうまくできてないと、あるべき順番であるべき機能がユーザに届けられなくなるのでそういうのはムダですよねという感じか。\r\n\r\n# リワーク(手戻り)\r\n## ムダ\r\n正しく行われたはずの納品物を変更するコスト\r\n## 原因\r\n- 技術的負債\r\n- ストーリーの却下（例：プロダクトマネージャーがストーリーの実装を却下）\r\n- 完了の明確な定義がない（ストーリーが曖昧、設計モックの推測）\r\n- 欠陥（テスト戦略の不備、バグの根本原因分析がない）。\r\n## 一言メモ\r\n仕様の作り込みが甘かったり、そもそもユーザーテストが不十分であやふやな機能が設計されたりして作り直しが発生するのはムダですよねという感じ。技術的負債やバグ起因で作り直しが発生するのもここの無駄にカウントされてる。\r\n\r\n# 不必要に複雑なソリューション\r\n## ムダ\r\n必要以上に複雑なソリューションを作成するコスト、機能、ユーザーインターフェース、コードを単純化する機会を逃す\r\n## 原因\r\n- ユーザーの視点から見た不必要な機能の複雑さ\r\n- 不必要な技術的複雑さ\r\n  - コードの重複、インタラクションデザインの再利用不足、前倒しで作った複雑すぎる技術的デザイン\r\n## 一言メモ\r\nオーバーエンジニアリングの結果、なんかかっこいいけど誰も容易に変更できなくなってしまったみたいな実装はたまにある気がする。しかもそれをやった人が退職してしまい結局全部書き直す羽目にみたいな、、やり直しが発生するという意味で確かにそういう実装は結局ムダと言われればムダ。\r\n\r\n# 不要な認知負荷\r\n## ムダ\r\n精神的エネルギーを不必要に消費するコスト\r\n## 原因\r\n- 技術的負債に苦しんでいる\r\n- 複雑または大規模なストーリー\r\n- 非効率なツールや問題のあるAPI、ライブラリ、フレームワーク\r\n- 不必要なコンテキストスイッチ\r\n- 非効率な開発フロー\r\n- 整理されていないコード\r\n## 一言メモ\r\n開発フローやツールや負債に起因してMPを過剰に消費させるのはムダですよねというやつ。\r\n\r\nそういえば精神的に負荷がかかることそれ自体がどのくらい開発の生産性低下を引き起こすのか知りたいんだけどそういう研究あるかな。例えば技術的負債によって発生する精神的な負荷は自体は実は生産性を低下させてなくて、技術的な負債そのものが生産性を低下させているだけみたいな。\r\n\r\nまぁMPが過剰に減らされるのは人間をリソースと考えるとムダだよねというのは当たり前だけど。\r\n\r\n# 心理的苦痛\r\n## ムダ\r\n不要なストレスでチームに負担をかけるコスト\r\n## 原因\r\n- チームのモラルの低下\r\n- ラッシュモード(締切がきつすぎるみたいな状況)\r\n- 対人関係やチーム内の対立\r\n## 一言メモ\r\nこれも上のやつと似ててMPの過剰消費に繋がるのでムダというやつ。\r\n\r\nそういえばフルリモートでissueベースで働いてると対人関係みたいなものを気にすることがほぼ無くなった。issueだけの関係だと後腐れなくて事務的に処理できることが多くて楽。一方でプロダクトを作っていくチームの一員としてビルドアップから参加する必要があると柔らかなコミュニケーションが必要になるので気を遣う。\r\n\r\n# 待ち時間/マルチタスク\r\n## ムダ\r\nマルチタスクに隠れがちなアイドルタイムのコスト\r\n## 原因\r\n- 遅いテストや信頼できないテスト\r\n- 信頼できない受け入れ環境\r\n- 不足する情報、人、設備\r\n- フィードバック遅延によるコンテキストスイッチ\r\n## 一言メモ\r\nテストが遅すぎたりPRのレビューがスルーされたりして先に進めない時に発生する待ち時間はムダですよね、というやつ。確かによく起きがちではあるが、PRのレビューで発生する待ちはどうしようもないところがあるな...。\r\n\r\n# ナレッジロス\r\n## ムダ\r\nチームがかつて知っていた情報を再取得するコスト\r\n## 原因\r\n- チームの解散や移動\r\n- 知識のサイロ化\r\n## 一言メモ\r\nチームの移動や変更でナレッジの共有をやり直すのに発生する時間とかがムダですよねというやつ。これは暗黙知を減らすために各人が情報をオープンに見える化しておかないと発生しがち。\r\n\r\nベテランの特定の人に質問が集中しちゃったりするとその人の本質的な作業時間が減るのもよくある。そういうベテランはそのプロダクトのあらゆることを知っているから開発のパフォーマンスも他の人より出せるはずなんだけど、オンボーディングを手伝うコストが度々発生しちゃたりすると勿体無いな〜となる。\r\n\r\n# 非効率的なコミュニケーション\r\n## ムダ\r\n不完全、不正確、誤解を招く、非効率的、または不在のコミュニケーションのコスト\r\n## 原因\r\n- チームサイズが大きすぎる\r\n- 非同期コミュニケーション\r\n  - 分散チーム、分散ステークホルダー、他のチームへの依存、チーム外の不透明なプロセス\r\n- 不均衡\r\n  - 会話を支配する、聞かない\r\n- 非効率な会議\r\n  - 集中力の欠如、振り返りのスキップ、毎日ブロッカーについて話さない(どういうこと...)、会議が長引く（例：長い立ち話）など\r\n## 一言メモ\r\nコミュニケーションがうまくいかないとムダですよねみたいな感じ。幅広いけどもまぁそれはそう。会議に関しても不要な話で盛り上がっちゃうとか曖昧な目的始まっちゃって終わりどころが見えずダラダラ続くみたいなことはよくある気がする。\r\n\r\n# 雑感\r\nソフトウェア開発におけるあるあるネタまとめみたいな様相である。こういうムダは確かに至る所に散見されるが、これらをどうやって取り除くかというのは中々難しい問題だ。だがその辺の対処法についてはこの論文に書いていない。\r\n\r\nこの辺りのムダを取り除くためのプロセス改善の話はどういう本(や記事や論文)を読むと良いのだろうか。","bodyHTML":"<p><a href=\"https://misreading.chat/2022/05/12/92-software-development-waste/\">Misreading Chat</a>で紹介されていた<a href=\"https://homepages.dcc.ufmg.br/~figueiredo/disciplinas/papers/icse17sedano.pdf\">Software Development Waste</a>という論文。</p>\n<p>この論文に載っていたTypes of Software Development Wasteというソフトウェア開発のムダについて類型されていたものが面白かったので日本語にしてみた。</p>\n<h1>誤った機能・製品の構築</h1>\n<h2>ムダ</h2>\n<p>ユーザーニーズやビジネスニーズに対応していない機能・製品を構築するコスト</p>\n<h2>原因</h2>\n<ul>\n<li>ユーザーの要望\n<ul>\n<li>ユーザー調査、検証、テストを行っていない、ユーザーフィードバックを無視している、ユーザー価値の低い機能に取り組んでいる</li>\n</ul>\n</li>\n<li>ビジネスの要望\n<ul>\n<li>ビジネス関係者を関与させていない、関係者からのフィードバックが遅い、製品の優先度が不明確</li>\n</ul>\n</li>\n</ul>\n<h2>一言メモ</h2>\n<p>ユーザーの声を汲み損ねていたり、えいやで作ってしまった機能とかまぁムダですよねと言われてばそう。割とよく起こりがちである。</p>\n<h1>バックログの管理ミス</h1>\n<h2>ムダ</h2>\n<p>作業の重複、価値の低いユーザー機能の迅速化、必要なバグ修正の遅延のコスト</p>\n<h2>原因</h2>\n<ul>\n<li>バックログの逆転</li>\n<li>同時に多くの機能に取り組む</li>\n<li>作業の重複</li>\n<li>十分に準備されていないストーリー(以降\"ストーリー\"は\"機能\"と同じ意味で使われてるっぽい？)</li>\n<li>機能開発とバグ修正のアンバランス</li>\n<li>テストまたは重要なバグ修正の遅延</li>\n<li>気まぐれなスラッシング(訳が微妙)</li>\n</ul>\n<h2>一言メモ</h2>\n<p>取り組むべきタスクの優先度づけがうまくできてないと、あるべき順番であるべき機能がユーザに届けられなくなるのでそういうのはムダですよねという感じか。</p>\n<h1>リワーク(手戻り)</h1>\n<h2>ムダ</h2>\n<p>正しく行われたはずの納品物を変更するコスト</p>\n<h2>原因</h2>\n<ul>\n<li>技術的負債</li>\n<li>ストーリーの却下（例：プロダクトマネージャーがストーリーの実装を却下）</li>\n<li>完了の明確な定義がない（ストーリーが曖昧、設計モックの推測）</li>\n<li>欠陥（テスト戦略の不備、バグの根本原因分析がない）。</li>\n</ul>\n<h2>一言メモ</h2>\n<p>仕様の作り込みが甘かったり、そもそもユーザーテストが不十分であやふやな機能が設計されたりして作り直しが発生するのはムダですよねという感じ。技術的負債やバグ起因で作り直しが発生するのもここの無駄にカウントされてる。</p>\n<h1>不必要に複雑なソリューション</h1>\n<h2>ムダ</h2>\n<p>必要以上に複雑なソリューションを作成するコスト、機能、ユーザーインターフェース、コードを単純化する機会を逃す</p>\n<h2>原因</h2>\n<ul>\n<li>ユーザーの視点から見た不必要な機能の複雑さ</li>\n<li>不必要な技術的複雑さ\n<ul>\n<li>コードの重複、インタラクションデザインの再利用不足、前倒しで作った複雑すぎる技術的デザイン</li>\n</ul>\n</li>\n</ul>\n<h2>一言メモ</h2>\n<p>オーバーエンジニアリングの結果、なんかかっこいいけど誰も容易に変更できなくなってしまったみたいな実装はたまにある気がする。しかもそれをやった人が退職してしまい結局全部書き直す羽目にみたいな、、やり直しが発生するという意味で確かにそういう実装は結局ムダと言われればムダ。</p>\n<h1>不要な認知負荷</h1>\n<h2>ムダ</h2>\n<p>精神的エネルギーを不必要に消費するコスト</p>\n<h2>原因</h2>\n<ul>\n<li>技術的負債に苦しんでいる</li>\n<li>複雑または大規模なストーリー</li>\n<li>非効率なツールや問題のあるAPI、ライブラリ、フレームワーク</li>\n<li>不必要なコンテキストスイッチ</li>\n<li>非効率な開発フロー</li>\n<li>整理されていないコード</li>\n</ul>\n<h2>一言メモ</h2>\n<p>開発フローやツールや負債に起因してMPを過剰に消費させるのはムダですよねというやつ。</p>\n<p>そういえば精神的に負荷がかかることそれ自体がどのくらい開発の生産性低下を引き起こすのか知りたいんだけどそういう研究あるかな。例えば技術的負債によって発生する精神的な負荷は自体は実は生産性を低下させてなくて、技術的な負債そのものが生産性を低下させているだけみたいな。</p>\n<p>まぁMPが過剰に減らされるのは人間をリソースと考えるとムダだよねというのは当たり前だけど。</p>\n<h1>心理的苦痛</h1>\n<h2>ムダ</h2>\n<p>不要なストレスでチームに負担をかけるコスト</p>\n<h2>原因</h2>\n<ul>\n<li>チームのモラルの低下</li>\n<li>ラッシュモード(締切がきつすぎるみたいな状況)</li>\n<li>対人関係やチーム内の対立</li>\n</ul>\n<h2>一言メモ</h2>\n<p>これも上のやつと似ててMPの過剰消費に繋がるのでムダというやつ。</p>\n<p>そういえばフルリモートでissueベースで働いてると対人関係みたいなものを気にすることがほぼ無くなった。issueだけの関係だと後腐れなくて事務的に処理できることが多くて楽。一方でプロダクトを作っていくチームの一員としてビルドアップから参加する必要があると柔らかなコミュニケーションが必要になるので気を遣う。</p>\n<h1>待ち時間/マルチタスク</h1>\n<h2>ムダ</h2>\n<p>マルチタスクに隠れがちなアイドルタイムのコスト</p>\n<h2>原因</h2>\n<ul>\n<li>遅いテストや信頼できないテスト</li>\n<li>信頼できない受け入れ環境</li>\n<li>不足する情報、人、設備</li>\n<li>フィードバック遅延によるコンテキストスイッチ</li>\n</ul>\n<h2>一言メモ</h2>\n<p>テストが遅すぎたりPRのレビューがスルーされたりして先に進めない時に発生する待ち時間はムダですよね、というやつ。確かによく起きがちではあるが、PRのレビューで発生する待ちはどうしようもないところがあるな...。</p>\n<h1>ナレッジロス</h1>\n<h2>ムダ</h2>\n<p>チームがかつて知っていた情報を再取得するコスト</p>\n<h2>原因</h2>\n<ul>\n<li>チームの解散や移動</li>\n<li>知識のサイロ化</li>\n</ul>\n<h2>一言メモ</h2>\n<p>チームの移動や変更でナレッジの共有をやり直すのに発生する時間とかがムダですよねというやつ。これは暗黙知を減らすために各人が情報をオープンに見える化しておかないと発生しがち。</p>\n<p>ベテランの特定の人に質問が集中しちゃったりするとその人の本質的な作業時間が減るのもよくある。そういうベテランはそのプロダクトのあらゆることを知っているから開発のパフォーマンスも他の人より出せるはずなんだけど、オンボーディングを手伝うコストが度々発生しちゃたりすると勿体無いな〜となる。</p>\n<h1>非効率的なコミュニケーション</h1>\n<h2>ムダ</h2>\n<p>不完全、不正確、誤解を招く、非効率的、または不在のコミュニケーションのコスト</p>\n<h2>原因</h2>\n<ul>\n<li>チームサイズが大きすぎる</li>\n<li>非同期コミュニケーション\n<ul>\n<li>分散チーム、分散ステークホルダー、他のチームへの依存、チーム外の不透明なプロセス</li>\n</ul>\n</li>\n<li>不均衡\n<ul>\n<li>会話を支配する、聞かない</li>\n</ul>\n</li>\n<li>非効率な会議\n<ul>\n<li>集中力の欠如、振り返りのスキップ、毎日ブロッカーについて話さない(どういうこと...)、会議が長引く（例：長い立ち話）など</li>\n</ul>\n</li>\n</ul>\n<h2>一言メモ</h2>\n<p>コミュニケーションがうまくいかないとムダですよねみたいな感じ。幅広いけどもまぁそれはそう。会議に関しても不要な話で盛り上がっちゃうとか曖昧な目的始まっちゃって終わりどころが見えずダラダラ続くみたいなことはよくある気がする。</p>\n<h1>雑感</h1>\n<p>ソフトウェア開発におけるあるあるネタまとめみたいな様相である。こういうムダは確かに至る所に散見されるが、これらをどうやって取り除くかというのは中々難しい問題だ。だがその辺の対処法についてはこの論文に書いていない。</p>\n<p>この辺りのムダを取り除くためのプロセス改善の話はどういう本(や記事や論文)を読むと良いのだろうか。</p>","active_lock_reason":null,"assignee":null,"assignees":[],"author_association":"OWNER","closed_at":null,"comments":0,"comments_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/10/comments","created_at":"2022-06-23T03:03:33Z","events_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/10/events","html_url":"https://github.com/YuheiNakasaka/gialog-diary/issues/10","id":1281601385,"labels":[],"labels_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/10/labels{/name}","locked":false,"milestone":null,"node_id":"I_kwDOHaM3jc5MY69p","number":10,"performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/10/reactions"},"repository_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary","state":"open","state_reason":null,"timeline_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/10/timeline","title":"ソフトウェア開発におけるムダ","updated_at":"2022-06-23T08:22:59Z","url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/10","user":{"avatar_url":"https://avatars.githubusercontent.com/u/1421093?v=4","events_url":"https://api.github.com/users/YuheiNakasaka/events{/privacy}","followers_url":"https://api.github.com/users/YuheiNakasaka/followers","following_url":"https://api.github.com/users/YuheiNakasaka/following{/other_user}","gists_url":"https://api.github.com/users/YuheiNakasaka/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/YuheiNakasaka","id":1421093,"login":"YuheiNakasaka","node_id":"MDQ6VXNlcjE0MjEwOTM=","organizations_url":"https://api.github.com/users/YuheiNakasaka/orgs","received_events_url":"https://api.github.com/users/YuheiNakasaka/received_events","repos_url":"https://api.github.com/users/YuheiNakasaka/repos","site_admin":false,"starred_url":"https://api.github.com/users/YuheiNakasaka/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/YuheiNakasaka/subscriptions","type":"User","url":"https://api.github.com/users/YuheiNakasaka"}},"issueComments":[],"pickupArticles":[{"body":"RustやTypeScriptに関するちょっと込み入ったドキュメントや記事を読んだりすると「部分型」だとか「多相」のようなワードが頻出するのだけどこれらの意味があんまりよくわかっていなかった。\r\n\r\n普段よく書いているプログラミング言語のはずなのにその(主に型の)解説で使われている単語が全くわからんというのはどうなのかというあたりに[型システム入門](https://amzn.to/3dPn7wK)(通称 TaPL)を読み始めたモチベーションがある。\r\n\r\nしかしまぁ普段プログラミングをしていると型キャストしたりジェネリクスを使ったりとか、何かしらの形でそういったワードに由来する言語機能を**使う経験**自体はすでにあり、今更小難しい話を知らなくても使い方はわかるので大して困ることもないわけで。\r\n\r\nそれにこの先プログラミング言語を本格的に開発する予定もないし、その理論的な意味といったものに特別興味を持つことはなかったわけだがふと[TypeScriptの型メモ](https://qiita.com/dico_leque/items/06ac5837b7a333c5c8da)というQiitaの記事なんかを読もうと思うと知らない単語が大量に出てきてぐぬぬ...となるのが不便というのもまた事実。\r\n\r\nBlockchain関連の開発の情報を追うのも少し飽きてきてたところなので良い機会と思い重い腰を上げた。\r\n\r\nAmazonから届いて読み始めた当初は噂に違わぬ難解な書籍であるな...と感じた。その辺りの苦慮は[型に関連するよく分からん用語がありすぎる](https://scrapbox.io/razokulover-tech-memo/%E5%9E%8B%E3%81%AB%E9%96%A2%E9%80%A3%E3%81%99%E3%82%8B%E3%82%88%E3%81%8F%E5%88%86%E3%81%8B%E3%82%89%E3%82%93%E7%94%A8%E8%AA%9E%E3%81%8C%E3%81%82%E3%82%8A%E3%81%99%E3%81%8E%E3%82%8B)に書いている...。\r\n\r\nとはいうものの実際10章くらいまでの型付きラムダ計算を理解し操作的意味論を読み下せるまで根気強く粘ることができれば、あとはそれ以降は全ての証明や演習問題は理解できるとは言わなくとも、各概念のエッセンスについて理解する土台は整う気がする。それでも全く簡単ではなく、特に後半はMLやHaskell等の関数型言語の経験がない自分には見たこともない概念だらけで苦戦した。\r\n\r\nちなみに型付きラムダ計算に関してはYoutubeに名大の木原准教授の講義動画があり、これが本当に大変素晴らしく、「あれ？俺、ラムダ計算完全に理解した！？！？」と錯覚させられるのでおすすめ。\r\n\r\n- [名大・講義 計算論](https://www.youtube.com/playlist?list=PLQJysrzOMzUlaYej_MMl5929fJ5A0qdLK)\r\n\r\n第Ⅲ章 部分型以降は、TaPL読む -> 知らない概念に出会う -> 本文を読み込む -> 意味わからん -> ググる -> 「OOOはXXXみたいなイメージやで」みたいな解説を読む -> 自分なりに噛み砕く -> TaPL読む -> 知らない概念に出会う -> ...の繰り返しになる。\r\n\r\n今でも全然理解出来ているとは思わないが以前よりは各種ワードに対するアレルギーのようなものはなく「OOOの言語で言うところのアレね」とか「なるほど、{ ∃X, T }のことね〜」、みたいな論理記号を見てやりたいことがほんのりわかるというくらいにはなってはきた。それだけでも読む価値があったなと思う。\r\n\r\n反面、言葉の意味的なものを知りたいだけならWikipediaなりググって各種大学の講義PDFとか読めば良いのでは？みたいな感覚もあった。あくまでTaPLは型理論を大学院以上で学んでいく学生に入門的な知識を授ける本なので、型についてちょっと知りたいくらいのレベルの人には重すぎるかも。その辺はご自身の体力とご相談という気がする。\r\n\r\nあと今後はHaskell・OCaml、あとはidrisあたりに手を出してみるとTaPLで出てきた完全に知らんかった概念を言語機能レベルで体感できて身になりそうだな〜と思った。これはこの先の宿題としてみる。","active_lock_reason":null,"assignee":null,"assignees":[],"author_association":"OWNER","closed_at":null,"comments":0,"comments_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/20/comments","created_at":"2022-08-27T09:22:56Z","events_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/20/events","html_url":"https://github.com/YuheiNakasaka/gialog-diary/issues/20","id":1352994529,"labels":[],"labels_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/20/labels{/name}","locked":false,"milestone":null,"node_id":"I_kwDOHaM3jc5QpQ7h","number":20,"performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/20/reactions"},"repository_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary","state":"open","state_reason":null,"timeline_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/20/timeline","title":"TaPLを読んでる","updated_at":"2022-08-27T10:03:43Z","url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/20","user":{"avatar_url":"https://avatars.githubusercontent.com/u/1421093?v=4","events_url":"https://api.github.com/users/YuheiNakasaka/events{/privacy}","followers_url":"https://api.github.com/users/YuheiNakasaka/followers","following_url":"https://api.github.com/users/YuheiNakasaka/following{/other_user}","gists_url":"https://api.github.com/users/YuheiNakasaka/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/YuheiNakasaka","id":1421093,"login":"YuheiNakasaka","node_id":"MDQ6VXNlcjE0MjEwOTM=","organizations_url":"https://api.github.com/users/YuheiNakasaka/orgs","received_events_url":"https://api.github.com/users/YuheiNakasaka/received_events","repos_url":"https://api.github.com/users/YuheiNakasaka/repos","site_admin":false,"starred_url":"https://api.github.com/users/YuheiNakasaka/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/YuheiNakasaka/subscriptions","type":"User","url":"https://api.github.com/users/YuheiNakasaka"}},{"body":"- 先日 OpenAI から[ChatGPT](https://chat.openai.com/chat)が Beta 公開された\r\n- ChatGPT ではどんな質問に対しても何かしらの回答を生成してくれるのだが、ソースコードに関しても中々の筋が良さそうな雰囲気のコード片を生成してくれるということで少し話題になっていた\r\n- こうしたプログラムを生成してくれる AI が発展していく中でどういう具合にプログラマの仕事が奪われていくのか興味がある\r\n- 特に以下では**web アプリやモバイルアプリなどのアプリケーションの開発において**という文脈で考えることにする\r\n- まず AI がプログラマの仕事を奪うまでにはいくつかの段階があると思う\r\n\r\n# コード支援レベル\r\n\r\n- 現状は[GitHub Copilot](https://github.com/features/copilot)のようなコーディング支援を行うレベルの AI はある程度実用レベルになっている\r\n  - 自分は Copilot が生成したコード片をプロダクションコードに含めるのは権利関係の問題もあり様子見している\r\n  - しかし Copilot を使っていないわけではなく、変数名や定型作業のサジェストや変数名の補完、コードの書き出しの補助などで利用している\r\n    - 例えば API のレスポンスで受け取る予定の JSON をペタッと貼るとそれにあった構造体とか型が丸ッと生成されたりする。スニペットとか静的なコードジェネレータでやってたような作業が良い感じにできるなど。\r\n  - 正直このようなコーディングの支援 AI だけではプログラマの仕事は AI に奪われないだろう。全然奪うというよりプログラマの手助けをするだけなので、これではまだまだプログラマがいないとアプリケーションは完成しない。\r\n\r\n# ChatGPT レベル\r\n\r\n- では ChatGPT のようにある程度まとまったサイズのコード片を生成してくれる AI が普及するとどうなるか\r\n  - Twitter ではさまざまなプログラマがコード片の生成を試みているがその内容を見るとそのまま使えるコードが半分、修正が必要なコードが 1〜2 割、完全に間違っているコードが 3〜4 割という感じだ\r\n  - 今のクオリティだと人が書いた方がまだ早い、もしくはプログラマによる手修正が結構必要そう。なのでプログラマがいないとまだアプリケーションは完成させられないだろう\r\n  - ただし修正すること前提で簡単なタスク用のまとまったコード片を生成してコーディングの時間短縮、といった使い方はできるかもしれない\r\n  - ある意味これもコーディング支援というレベルではある\r\n    - というか GitHub Copilot が GPT-3 を使ってるから実質同じといえば同じ\r\n\r\n# かなり高精度にコード生成できるレベル\r\n\r\n- ではそのまま使えるコード片を ほぼ 100%のクオリティで生成できる AI が登場するようになるとどうか\r\n  - ここまでくると AI に生成してほしいコードの内容を伝えてコード片を大量に生成してもらい、それをプログラマが組み合わせてアプリケーションという形にする流れでも現実的になってきそう\r\n    - 例えば「メールアドレス認証するコード書いて」「CRUD なフォームのモデルとコントローラとビューを書いて」等々でいくつかの動くコード片が生成される\r\n    - 人間はこれらをつなぎ合わせるだけでアプリケーションが完成するイメージ\r\n      - こうしたコード片をつなぎ合わせる仕事はアセンブリエンジニアとでも呼ばれるようになりそう\r\n  - **AI には体力が無いかつマシンさえあれば並列で大量に実行できるという人間には成し得ない強力な生産性がある**\r\n    - 金とマシンさえあれば 24 時間並列で一気にコード生成してもらえるはず\r\n  - よって例えば今までだと新規でアプリケーションを完成させるのに必要なプログラマが 1 人月必要だった案件でも AI にコーディング部分を大幅に代替してもらえるなら一部コード修正やレビューが必要にしても、数人日で完成させられるようなことはあるかもしれない\r\n  - この辺りから一部のプログラマの仕事は AI に奪われたと言われるようになるだろう\r\n- とはいえこれらは**新規開発の場合のみの話**だ\r\n- 仕事におけるプロダクションで稼働するシステム開発の難易度の高い部分は既存システムへ追加・修正などの改修を入れるところである\r\n- どんなに正確なコード片を生成できたり、あるいはアプリケーション全体のコードを生成できたとしてもそれは新規開発時のコーディングの代替であり、一度本番に乗ってしまったコードを運用していく際にはちょっとやそっとのコード片の生成レベルでは代替は難しそうだ\r\n\r\n# 既存コードのコンテキストも読み取ってコード生成できるレベル\r\n\r\n- では改修要望を書くと既存コードのコンテキストを加味した状態の追加修正が入ったコードが丸っと生成されるようになるとどうか\r\n  - これが出来るならアプリケーションのコーディング部分を担当するプログラマはほぼ不要になるかもしれない\r\n    - 生成されたコードを既存コードに適用するくらいで済むレベルを想定\r\n  - 残りの仕事に必要なのは下記くらいか\r\n    - 生成されたコードが安定して実行し続けられるように周辺環境を作るインフラエンジニア\r\n    - 生成されたコードに問題はないか確認するコードレビューエンジニア\r\n    - 生成されたコードが想定通りに動くか確認する QA エンジニア\r\n    - AI のコード生成や生成したコードを管理するプロンプトエンジニア/アセンブリエンジニア?\r\n      - AI の癖を知り既存コードとの相性の良いプロンプトを管理するご機嫌伺い役\r\n- ここまでくると新規開発だけでなく既存システムの改修に関するコーディングはある程度代替できるのでさらに従来のプログラマの仕事は減らせるかもしれない\r\n\r\n# さらに先の話\r\n\r\n- さらに AI がプログラマの仕事を奪うにはどんなことが必要か\r\n  - 生成されたアプリケーションを実行管理し安定運用してくれるインフラをなんとかしてもらう必要がありそう\r\n    - 生成されたアプリケーションと想定するサービス品質などを指定すると自動でインフラを展開して運用までやってくれるような仕組みはできるか？\r\n    - サーバー・ネットワーク・DB などの知識を隠蔽できるか？\r\n    - トラブルシューティングは可能か？\r\n      - この辺りができないとインフラ系のエンジニアの仕事はなくせなそう\r\n  - アプリケーションが正しく動いているか保証できる必要がありそう\r\n    - 想定外の挙動はないかコードレビューする\r\n    - 生成されたコードが想定通りの動作をしているかテストを書く\r\n    - 生成されたコードが想定通りの動作をしているか動作確認を行う\r\n    - 誤作動した時にストップできる\r\n      - この辺りを担保できないと品質保証系のエンジニアの仕事はなくせなそう\r\n- その他仕事に関してはどうか？\r\n  - 他の役職に関しては詳しくないので何もいえない\r\n    - というか自分の理解が浅いかもしれない職に関して簡単に奪われる職として挙げるのは憚られる\r\n\r\n# 雑多な話\r\n\r\n## 生成されるコード\r\n\r\n- AI が生成するコードは既存のプログラミング言語で書かれたコードである必要はあるのか\r\n  - コード片を人間が読まなくても良いレベルのクオリティなら既存の言語で吐き出す意味はないのでは\r\n    - トラブルシューティングしづらそう\r\n    - 過去の資産(GitHub 上のコードとか)を利用するなら既存のプログラミング言語の方が吐き出しやすそうではある\r\n- AI が吐き出しやすいようなコードを書くという価値観が新たにコーディング規約に追加されたりするかも\r\n- そもそも実行バイナリを吐き出すだけではダメか？\r\n  - 実行バイナリをブラックボックステストであとは QA エンジニアが検証するだけのお仕事で良いのでは\r\n    - とはいえトラブルシューティングしづらそうなのはキツいか\r\n\r\n## 開発体験\r\n\r\n- 開発体験(DX)の向上は必要か？\r\n  - AI が大方のコード生成をしてくれるなら開発体験の向上にコストをかける必要はあるのか\r\n  - プログラマがコードに手を入れなくても良いなら lint とか formatter とか型とかもいらないのでは\r\n- プログラミング言語やフレームワークの選定はどう変わるか？\r\n  - AI が一番精度良く吐き出せる言語が人気になるか\r\n  - ただまぁこれは今と変わらず要件次第になりそうではあるな\r\n\r\n## プログラマの仕事\r\n\r\n- プログラマの仕事はどう変わるか\r\n  - コードを書く比重が減り、コード片を生成する作業とシステムを組み上げる作業に比重が移りそう\r\n  - 要件を分解しシステムを構成するコード片を生成するためのプロンプト作成作業が大量に発生しそう\r\n  - より必要になる能力\r\n    - 業務知識への明るさ\r\n    - 調整能力(コミュニケーション力含め)\r\n    - 要件の分解とそのそれぞれへの解決策を文章化する能力\r\n    - **システム全体**の設計力\r\n  - 今も似たようなことをやってるはずだし必要な能力は変わらなそう\r\n  - コード化する部分がめちゃくちゃ爆速になるだけか？\r\n- フロントエンドエンジニアとかバックエンドエンジニアみたいな職域の境はなくなり、システム全体を設計して形にできる全部できる強いフルスタックな人が 1 人いればアプリケーション開発には十分というチーム構成になる可能性はあるかも\r\n- システムの安定性を向上させたり保証する仕事の重要性が増しそう\r\n  - 要は**AI の尻拭い**\r\n    - テストや QA を手厚くやって AI の生成したコードの穴を塞ぐ仕事\r\n    - コードレビューの仕事\r\n  - QA 用 AI が出てくる可能性もあるが、その AI の QA を誰がやるのか？とかその AI は業務依存の実装になりそうなので維持管理は内製になりそう\r\n    - AI より安いマンパワーを使った方がコスパ良いとかありそう\r\n- インフラ周りは構築はまだしも運用を完全に AI に代替させることで仕事を奪わせるのは難しそうに感じる、というか想像できない\r\n  - ただ自社で DC 持ってるとかよっぽど特殊な要件のアプリケーションでなければクラウドベンダが良い感じのソリューションを出してきそうではある。昔に比べたら今でも十分インフラは深い知識なくてもある程度構築運用できるし。\r\n- 責任を取ること\r\n  - AI のミスの尻拭いは人間がやる\r\n\r\n## 完全に未知の概念に対応できるか\r\n\r\n- 「イスカルテンダ王国のスルマオン暦のランフォイを求めるコード」みたいな未知の概念は AI に正しく対応できない(はず)\r\n- AI が知らないものは人間が頑張るしかない\r\n\r\n## AI の学習ソースはどうなるのか\r\n\r\n- 現状は GitHub やインターネット上のコードを学習してモデルを作ってると思うが、近い将来学習ソースが枯渇するという話がある\r\n- 将棋 AI は将棋 AI の生成した棋譜をさらに学習したりしているが、AI が生成したプログラミングのコードをさらに学習したりすれば解決するか？\r\n  - 将棋における[floodgate](http://wdoor.c.u-tokyo.ac.jp/shogi/floodgate.html)みたいな AI が作ったソースコードが実行されたり共有されたりするものが生まれるか？\r\n\r\n## 信頼性\r\n\r\n- AI が生成したコードをどこまで信頼できるか\r\n  - 例えばある手術に使われる機器のソフトウェアが一切人間の手が入っていない AI による自動生成コードで作られているとして、自分の娘がその機器で手術を受けると知ったら、今の AI のレベルなら 100%手術をやめさせると思う\r\n  - その信頼性を**担保するための仕事**(コードを人間が書くべきといっているわけではない)はしばらくは人間の仕事になりそう\r\n  - 特に人の営みと高度に接続する必要がある場面では避けられないように思う\r\n    - AI にはパーソナリティや家族のような守るべきものが(現時点では)ないという点がある種の弱点(利点)な気がする\r\n- AI は人との営みの中で何か重要なことを行うためには責任感が足りなすぎる\r\n  - 失敗しましたごめんな！で済まない場面への対応を整備する必要がありそう\r\n  - そうなると責任は開発(会社|者)が取るしかない。AI の尻拭いは人間がやる。\r\n- ある程度無責任でも良い場面には使えるが強く責任が伴う場面では、失敗した場合のケアや予防策を構築する必要がある\r\n\r\n## シンギュラリティ\r\n\r\n- AI が考え、AI が解決案を生み出し、また AI が問題を見つけ、AI が解決を試みるみたいなシンギュラリティ的な世界は一部の分野ではもうすぐあり得そう\r\n- 社会の中でも広く適用されるためには失敗の責任を自分で取れる、自分で尻拭いできる能力が AI に生まれたら世界は変わりそう。まだまだ SF っぽいだいぶ先の話な気もする。\r\n- プログラマはAIの失敗の尻拭いをするために謝罪の練習をしておくと良さそう(?)","active_lock_reason":null,"assignee":null,"assignees":[],"author_association":"OWNER","closed_at":null,"comments":0,"comments_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/26/comments","created_at":"2022-12-03T08:28:02Z","events_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/26/events","html_url":"https://github.com/YuheiNakasaka/gialog-diary/issues/26","id":1473845983,"labels":[],"labels_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/26/labels{/name}","locked":false,"milestone":null,"node_id":"I_kwDOHaM3jc5X2Rrf","number":26,"performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/26/reactions"},"repository_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary","state":"open","state_reason":null,"timeline_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/26/timeline","title":"どのようにしてプログラマはAIに仕事を奪われていくかの妄想","updated_at":"2022-12-03T08:28:02Z","url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/26","user":{"avatar_url":"https://avatars.githubusercontent.com/u/1421093?v=4","events_url":"https://api.github.com/users/YuheiNakasaka/events{/privacy}","followers_url":"https://api.github.com/users/YuheiNakasaka/followers","following_url":"https://api.github.com/users/YuheiNakasaka/following{/other_user}","gists_url":"https://api.github.com/users/YuheiNakasaka/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/YuheiNakasaka","id":1421093,"login":"YuheiNakasaka","node_id":"MDQ6VXNlcjE0MjEwOTM=","organizations_url":"https://api.github.com/users/YuheiNakasaka/orgs","received_events_url":"https://api.github.com/users/YuheiNakasaka/received_events","repos_url":"https://api.github.com/users/YuheiNakasaka/repos","site_admin":false,"starred_url":"https://api.github.com/users/YuheiNakasaka/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/YuheiNakasaka/subscriptions","type":"User","url":"https://api.github.com/users/YuheiNakasaka"}},{"body":"[目の見えない人は世界をどう見ているのか](https://amzn.to/3P9Tl3g)という本を読んだ。その中に目の見える人と目の見えない人が美術館で一緒に作品を鑑賞するソーシャルビューという試みが書いてあった。\r\n\r\nソーシャルビューではまず見える人が作品について語る。その際に重視するのは作品の形や客観的な情報ではなく本人の主観的な感想だ。それを聞いた目の見えない人たちはどう言った作品なのか想像しながら質問したり感想を述べたりする。このインタラクティブなやり取りの中で互いに作品の意図や意味を感じ楽しむ。このような美術鑑賞の試みがソーシャルビューである。\r\n\r\n> 情報化の時代にわざわざ集まってみんなで鑑賞する面白さは、見えないもの、つまり「意味」の部分を共有すること\r\n\r\n作品そのものを見るだけで得られるものはただのデータである。そのデータを受けた鑑賞者がそこにどのような意味を見出すのか。その共有を通じて目の見えない人は作品を脳内で立体的に補完し、さらにその補完した作品を受けてそこに自らの意味を見出していく。こういう営みだ。\r\n\r\n> 作品を鑑賞するとは自分で作品を作り直すこと\r\n\r\n「鑑賞する = 自分で作り直す」という文章に感銘を受けた。\r\n\r\nというのも自分は鑑賞が苦手だからだ。映画やアニメや漫画などあらゆる物語に対してそのストーリーを追うことしかできない。キャラクターに感情移入することもないしストーリーの不自然さに苛立つこともない。だから深読みとか考察みたいなものもできない。登場人物のパラメータの暗記と筋書きを追うことで満足してしまう。\r\n\r\nいわば\"物語\"という食べ物を食べても消化されずに排泄されてしまう感覚に近い。胃で消化されず腸で吸収されず体の一部になるような、そういう摂取の仕方が\"鑑賞\"なのだと思うのだけど、自分の場合は舌で感じた味くらいしか摂取できないわけだ。\r\n\r\n大味なバトル漫画を読んだりするときは心臓がバクバクすることもある。スナック菓子を食べているような感覚。刺激の強い味はどんどん食べたくなるしよく噛まずに早食いになる。物語を異常な速度で雑に食ってると変なアドレナリンが出ちゃうのだと思う。\r\n\r\nこれは老化とか体調が悪いからとかそういうのは関係なくて昔からこんな感じである。むしろそういう自分に自覚的になってきた分まだマシだ。\r\n\r\n鑑賞することは自分で作り直すということであるならば、自分は全く鑑賞が出来ていない。勿体無いなと思う。クリティカルシンキングだとか共感性の問題だとか、色々と理由はあるのかもしれないが浅い人間だな〜と感じてしまう。\r\n\r\nそういえばオードリーのオールナイトニッポンで春日が何十年もジャンプを読み続けているがどの作品も誰々が強いとか弱いみたいな話だけで自分と作品との関係から出てくる感想とか考察みたいなものが一切なくて若林にdisられてたのを聞いてめちゃくちゃ共感と安心感を覚えた。俺だ〜〜〜となった。","active_lock_reason":null,"assignee":null,"assignees":[],"author_association":"OWNER","closed_at":null,"comments":0,"comments_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/12/comments","created_at":"2022-07-08T09:00:11Z","events_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/12/events","html_url":"https://github.com/YuheiNakasaka/gialog-diary/issues/12","id":1298710077,"labels":[],"labels_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/12/labels{/name}","locked":false,"milestone":null,"node_id":"I_kwDOHaM3jc5NaL49","number":12,"performed_via_github_app":null,"reactions":{"+1":0,"-1":0,"confused":0,"eyes":0,"heart":0,"hooray":0,"laugh":0,"rocket":0,"total_count":0,"url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/12/reactions"},"repository_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary","state":"open","state_reason":null,"timeline_url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/12/timeline","title":"鑑賞が出来ない","updated_at":"2022-07-08T09:00:11Z","url":"https://api.github.com/repos/YuheiNakasaka/gialog-diary/issues/12","user":{"avatar_url":"https://avatars.githubusercontent.com/u/1421093?v=4","events_url":"https://api.github.com/users/YuheiNakasaka/events{/privacy}","followers_url":"https://api.github.com/users/YuheiNakasaka/followers","following_url":"https://api.github.com/users/YuheiNakasaka/following{/other_user}","gists_url":"https://api.github.com/users/YuheiNakasaka/gists{/gist_id}","gravatar_id":"","html_url":"https://github.com/YuheiNakasaka","id":1421093,"login":"YuheiNakasaka","node_id":"MDQ6VXNlcjE0MjEwOTM=","organizations_url":"https://api.github.com/users/YuheiNakasaka/orgs","received_events_url":"https://api.github.com/users/YuheiNakasaka/received_events","repos_url":"https://api.github.com/users/YuheiNakasaka/repos","site_admin":false,"starred_url":"https://api.github.com/users/YuheiNakasaka/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/YuheiNakasaka/subscriptions","type":"User","url":"https://api.github.com/users/YuheiNakasaka"}}]},"__N_SSG":true}